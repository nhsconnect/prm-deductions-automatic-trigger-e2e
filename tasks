#!/usr/bin/env bash

set -Eeo pipefail

###########################
# Local Config Parameters #
###########################

export AWS_DEFAULT_REGION=eu-west-2
export AWS_REGION=eu-west-2
IMAGE_REPO_NAME=deductions/prm-deductions-automatic-trigger-e2e
export NHS_SERVICE=prm-deductions-automatic-trigger-e2e
AWS_HELPERS_VERSION=0.2.19
echo "AWS helper scripts version: $AWS_HELPERS_VERSION"

# Do not change the file name as the aws helper scripts depend on it
AWS_HELPERS_FILE="utils/$AWS_HELPERS_VERSION/aws-helpers"

mkdir -p "utils/$AWS_HELPERS_VERSION"
if [[ ! -f $AWS_HELPERS_FILE ]];then
  wget --quiet -O $AWS_HELPERS_FILE https://github.com/nhsconnect/prm-deductions-support-infra/releases/download/${AWS_HELPERS_VERSION}/aws-helpers
fi
chmod +x $AWS_HELPERS_FILE
source $AWS_HELPERS_FILE

####################################
# Instance (Environment) Variables #
####################################

function check_env {
  if [[ -z "${NHS_ENVIRONMENT}" ]]; then
    echo "Must set NHS_ENVIRONMENT"
    exit 1
  fi
}

function set_image_tag() {
  export IMAGE_TAG=$(git rev-parse HEAD | cut -c 1-8)
}

function configure_local_envs {
  export NHS_ENVIRONMENT=local
}

function configure_mesh_access {
  mesh_mailbox_id="/repo/dev/user-input/external/mesh-mailbox-id"
  echo "${mesh_mailbox_id}"
  mesh_client_cert="/repo/${NHS_ENVIRONMENT}/user-input/external/mesh-mailbox-client-cert"
  echo "${mesh_client_cert}"
  mesh_client_key="/repo/${NHS_ENVIRONMENT}/user-input/external/mesh-mailbox-client-key"

  export MESH_MAILBOX_ID=$(dojo -c Dojofile-infra "aws ssm get-parameter --with-decryption --region ${AWS_DEFAULT_REGION} --name  ${mesh_mailbox_id} | jq -r .Parameter.Value")
  export MESH_CLIENT_CERT=$(dojo -c Dojofile-infra "aws ssm get-parameter --with-decryption --region ${AWS_DEFAULT_REGION} --name  ${mesh_client_cert} | jq -r .Parameter.Value")
  export MESH_CLIENT_KEY=$(dojo -c Dojofile-infra "aws ssm get-parameter --with-decryption --region ${AWS_DEFAULT_REGION} --name  ${mesh_client_key} | jq -r .Parameter.Value")
}

function get_suspension_service_cluster_name {
  cluster_ssm_param_name="/repo/${NHS_ENVIRONMENT}/output/suspension-service/suspension-service-ecs-cluster-name"
  export SUSPENSION_SERVICE_CLUSTER_NAME=$(dojo -c Dojofile-infra "aws ssm get-parameter --with-decryption --region ${AWS_DEFAULT_REGION} --name  ${cluster_ssm_param_name} | jq -r .Parameter.Value")
  echo $SUSPENSION_SERVICE_CLUSTER_NAME
}

function get_running_task_count {
  echo $(aws ecs describe-clusters \
        --cluster "$1" \
        --region "$AWS_REGION" \
        | jq -r '.clusters[0].runningTasksCount')
}

function check_suspension_service {
  if [[ "$NHS_ENVIRONMENT" != "test" ]]; then
    echo "We're not checking suspension-service for dev env"
    return 0
  fi
  POLLING_ATTEMPTS_LEFT=6
  CLUSTER_NAME=$(get_suspension_service_cluster_name)
  while [ "$POLLING_ATTEMPTS_LEFT" -gt "0" ]; do
    TASKS_COUNT=$(get_running_task_count ${CLUSTER_NAME})

    echo "Number of running tasks found: $TASKS_COUNT"

    if [[ "$TASKS_COUNT" -eq "0" || "$TASKS_COUNT" == "null" ]]; then
      let POLLING_ATTEMPTS_LEFT--
      echo "No running task found. Making another attempt. Attempts left: $POLLING_ATTEMPTS_LEFT"
      sleep 180 #3 mins
    else
      echo "Found $TASKS_COUNT running tasks in $CLUSTER_NAME"
      return 0
    fi
  done

  echo "Can't find a running task in $CLUSTER_NAME"
  exit 1
}

function set_required_role_arn_from_assumed_role() {
  export REQUIRED_ROLE_ARN=$(dojo -c Dojofile-infra "aws sts get-caller-identity | jq -r .Arn")
}

function get_stage_run_history() {
  curl --silent --fail "https://$GOCD_HOST/go/api/stages/$1/$2/history" \
        $GOCD_API_CURL_OPTIONS \
        -H "Authorization: bearer $GOCD_API_TOKEN" \
        -H 'Accept: application/vnd.go.cd.v3+json'
}

function get_latest_stage_run_status() {
  get_stage_run_history $1 $2 | jq -r .stages[0].jobs[0].state
}


###########
## TASKS ##
###########

command="$1"
case "${command}" in
  _dep)
      gradle dependencyCheckAnalyze
      ;;
  dep)
      dojo "./tasks _dep"
      ;;
  _test_continuity_e2e)
     gradle test --tests "uk.nhs.prm.deduction.e2e.tests.ContinuityE2E"
      ;;
  test_continuity_e2e)
      check_env
      assume_environment_role $NHS_ENVIRONMENT
      check_suspension_service
      dojo "./tasks _test_continuity_e2e"
      ;;
  _test_repo_e2e)
      gradle test --tests "uk.nhs.prm.deduction.e2e.tests.RepositoryE2ETests"
      ;;
  test_repo_e2e)
      check_env
      assume_environment_role $NHS_ENVIRONMENT
      dojo "./tasks _test_repo_e2e"
      ;;
  _livetest_inject)
      gradle test --tests InjectChangeOfGPMessageTest
      ;;
  livetest_inject)
      check_env
      assume_environment_role $NHS_ENVIRONMENT
      dojo "./tasks _livetest_inject"
      ;;
  _livetest_day1_test)
      gradle test --tests ChangeOfGPMessageReceivedTest
      ;;
  livetest_day1_test)
      check_env
      assume_environment_role $NHS_ENVIRONMENT
      dojo "./tasks _livetest_day1_test"
      ;;
  _livetest_day2_test)
      gradle test --tests ValidateMOFUpdatedTest
      ;;
  livetest_day2_test)
      check_env
      assume_environment_role $NHS_ENVIRONMENT
      dojo "./tasks _livetest_day2_test"
      ;;
  _livetest_repo_test)
      gradle test --tests ValidateEhrTransferToRepoUsingMofTest
      ;;
  livetest_repo_test)
      check_env
      assume_environment_role $NHS_ENVIRONMENT
      dojo "./tasks _livetest_repo_test"
      ;;
  _test_perf_unit)
      gradle test --tests *.performance.*.*Test
      ;;
  test_perf_unit)
      dojo "./tasks _test_perf_unit"
      ;;
  _test_performance)
      gradle test --tests *.PerformanceTest
      ;;
  test_performance_local) # using local user auth
      check_env
      assume_environment_role $NHS_ENVIRONMENT
      dojo "./tasks _test_performance"
      ;;
  test_performance) # in pipeline
      check_env

      assume_environment_role $NHS_ENVIRONMENT
      set_required_role_arn_from_assumed_role
      echo "set REQUIRED_ROLE_ARN to $REQUIRED_ROLE_ARN for long-running test process"

      echo "NB: clearing temporary auth session credentials to allow native AWS auth access to re-assume role after expiry"
      _clear_aws_env_credentials

      dojo "./tasks _test_performance"
      ;;
  _test_repo_in_performance)
      gradle test --tests *.RepoInPerformanceTest
      ;;
  test_repo_in_performance)
      check_env

      assume_environment_role $NHS_ENVIRONMENT
      set_required_role_arn_from_assumed_role
      echo "set REQUIRED_ROLE_ARN to $REQUIRED_ROLE_ARN for long-running test process"

      echo "NB: clearing temporary auth session credentials to allow native AWS auth access to re-assume role after expiry"
      _clear_aws_env_credentials

      dojo "./tasks _test_repo_in_performance"
      ;;
  _test_technical)
      gradle test --tests *ChangeOfGPMessageReceivedTest
      ;;
  test_technical)
      ;;
  _ehr_tool)
      export MESSAGES_DIR=tools/large-ehr-inspector/samples
      export TEMPLATE_MESSAGE_ID=9e6f8d45-913a-4c67-89f3-10d131fc332c
      export TARGET_MESSAGE_ID=be6f8d45-913a-4c67-89f3-10d131fc332c
      gradle ehrTool
      ;;
  _check_gocd_job)
      GOCD_API_TOKEN_PARAM="/repo/user-input/gocd-access-token"
      GOCD_API_TOKEN=$(aws ssm get-parameter --with-decryption --region ${AWS_DEFAULT_REGION} --name ${GOCD_API_TOKEN_PARAM} | jq -r .Parameter.Value)
      GOCD_HOST=prod.gocd.patient-deductions.nhs.uk

      # simplified pipelines next steps:

      # create versions manifest - then can just check is identical at end of tests?
      # ... well not quite if you want to optimise - as e.g. if one gets scheduled or assigned
      # but is not building yet, it needn't invalidate run, but for simplicity making sure all are in state completed
      # at start and end of run, including which pipeline stage and job run number

      # if start and end manifests not identical, fail build due to potential changes while tests running (tests
      # should then automatically re-run when in-flight or completed change triggers this test job again)

      # next is to find latest previous passing run of this e2e tests job

      # then next is to compare this manifests versions to previous passing manifest, and trigger next stages in those
      # pipelines that have different version IDs... or maybe actually safer to check latest completed next stage on
      # each microservice pipeline and trigger next stage if doesn't match? probably the prior - stick to e2e tests
      # triggering with reference to itself and prebvious runs - if other failures or re-runs occur that is a case for
      # manual repair

      # think about / try inline e2e-tests in microservices pipelines? probs need to check only one e2e tests running at
      # a time as well as no other deploys going on

      # existing microservice pipelines
      echo mesh-forwarder deploy is $(get_latest_stage_run_status prm-deductions-mesh-forwarder.dev deploy)
      echo nems-event-processor deploy is $(get_latest_stage_run_status prm-deductions-nems-event-processor.dev deploy)
      echo suspension-service deploy is $(get_latest_stage_run_status suspension-service.dev deploy)
      echo re-registration-service deploy is $(get_latest_stage_run_status re-registration-service.dev deploy)

      # linear spike ones
      echo spiked pds-adaptor deploy is $(get_latest_stage_run_status pds-adaptor deploy.dev)
      echo automatic material dependency locator for pds-adaptor material is $GO_DEPENDENCY_LOCATOR_PDS_ADAPTOR

      ;;
  check_gocd_job)
      dojo -c Dojofile-infra "./tasks _check_gocd_job $2"
      ;;
  *)
      echo "Invalid command: '${command}'"
      exit 1
      ;;

esac
set +e
