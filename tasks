#!/usr/bin/env bash

set -Eeo pipefail

###########################
# Local Config Parameters #
###########################

export AWS_DEFAULT_REGION=eu-west-2
export AWS_REGION=eu-west-2
IMAGE_REPO_NAME=deductions/prm-deductions-automatic-trigger-e2e
export NHS_SERVICE=prm-deductions-automatic-trigger-e2e
AWS_HELPERS_VERSION=0.2.19
echo "AWS helper scripts version: $AWS_HELPERS_VERSION"

# Do not change the file name as the aws helper scripts depend on it
AWS_HELPERS_FILE="utils/$AWS_HELPERS_VERSION/aws-helpers"

mkdir -p "utils/$AWS_HELPERS_VERSION"
if [[ ! -f $AWS_HELPERS_FILE ]];then
  wget --quiet -O $AWS_HELPERS_FILE https://github.com/nhsconnect/prm-deductions-support-infra/releases/download/${AWS_HELPERS_VERSION}/aws-helpers
fi
chmod +x $AWS_HELPERS_FILE
source $AWS_HELPERS_FILE

####################################
# Instance (Environment) Variables #
####################################

function check_env {
  if [[ -z "${NHS_ENVIRONMENT}" ]]; then
    echo "Must set NHS_ENVIRONMENT"
    exit 1
  fi
}

function set_image_tag() {
  export IMAGE_TAG=$(git rev-parse HEAD | cut -c 1-8)
}

function configure_local_envs {
  export NHS_ENVIRONMENT=local
}

function configure_mesh_access {
  mesh_mailbox_id="/repo/dev/user-input/external/mesh-mailbox-id"
  echo "${mesh_mailbox_id}"
  mesh_client_cert="/repo/${NHS_ENVIRONMENT}/user-input/external/mesh-mailbox-client-cert"
  echo "${mesh_client_cert}"
  mesh_client_key="/repo/${NHS_ENVIRONMENT}/user-input/external/mesh-mailbox-client-key"

  export MESH_MAILBOX_ID=$(dojo -c Dojofile-infra "aws ssm get-parameter --with-decryption --region ${AWS_DEFAULT_REGION} --name  ${mesh_mailbox_id} | jq -r .Parameter.Value")
  export MESH_CLIENT_CERT=$(dojo -c Dojofile-infra "aws ssm get-parameter --with-decryption --region ${AWS_DEFAULT_REGION} --name  ${mesh_client_cert} | jq -r .Parameter.Value")
  export MESH_CLIENT_KEY=$(dojo -c Dojofile-infra "aws ssm get-parameter --with-decryption --region ${AWS_DEFAULT_REGION} --name  ${mesh_client_key} | jq -r .Parameter.Value")
}

function get_suspension_service_cluster_name {
  cluster_ssm_param_name="/repo/${NHS_ENVIRONMENT}/output/suspension-service/suspension-service-ecs-cluster-name"
  export SUSPENSION_SERVICE_CLUSTER_NAME=$(dojo -c Dojofile-infra "aws ssm get-parameter --with-decryption --region ${AWS_DEFAULT_REGION} --name  ${cluster_ssm_param_name} | jq -r .Parameter.Value")
  echo $SUSPENSION_SERVICE_CLUSTER_NAME
}

function get_running_task_count {
  echo $(aws ecs describe-clusters \
        --cluster "$1" \
        --region "$AWS_REGION" \
        | jq -r '.clusters[0].runningTasksCount')
}

function check_suspension_service {
  if [[ "$NHS_ENVIRONMENT" != "test" ]]; then
    echo "We're not checking suspension-service for dev env"
    return 0
  fi
  POLLING_ATTEMPTS_LEFT=6
  CLUSTER_NAME=$(get_suspension_service_cluster_name)
  while [ "$POLLING_ATTEMPTS_LEFT" -gt "0" ]; do
    TASKS_COUNT=$(get_running_task_count ${CLUSTER_NAME})

    echo "Number of running tasks found: $TASKS_COUNT"

    if [[ "$TASKS_COUNT" -eq "0" || "$TASKS_COUNT" == "null" ]]; then
      let POLLING_ATTEMPTS_LEFT--
      echo "No running task found. Making another attempt. Attempts left: $POLLING_ATTEMPTS_LEFT"
      sleep 180 #3 mins
    else
      echo "Found $TASKS_COUNT running tasks in $CLUSTER_NAME"
      return 0
    fi
  done

  echo "Can't find a running task in $CLUSTER_NAME"
  exit 1
}

function set_required_role_arn_from_assumed_role() {
  export REQUIRED_ROLE_ARN=$(dojo -c Dojofile-infra "aws sts get-caller-identity | jq -r .Arn")
}

function init_gocd_api_access() {
  if [[ -z "${GOCD_API_TOKEN}" ]]; then
    export GOCD_API_TOKEN_PARAM="/repo/user-input/gocd-access-token"
    export GOCD_API_TOKEN=$(aws ssm get-parameter --with-decryption --region ${AWS_DEFAULT_REGION} --name ${GOCD_API_TOKEN_PARAM} | jq -r .Parameter.Value)
    export GOCD_HOST=prod.gocd.patient-deductions.nhs.uk
  fi
}

function get_stage_run_history() {
  local pipeline_name=$1
  local stage_name=$2

  init_gocd_api_access

  curl --silent --fail "https://$GOCD_HOST/go/api/stages/$pipeline_name/$stage_name/history" \
    $GOCD_API_CURL_OPTIONS \
    -H "Authorization: bearer $GOCD_API_TOKEN" \
    -H 'Accept: application/vnd.go.cd.v3+json'
}

function trigger_stage_run() {
  local stage_spec=$1

  echo triggering $stage_spec

  init_gocd_api_access

  curl --silent --fail "https://$GOCD_HOST/go/api/stages/$stage_spec/run" \
    $GOCD_API_CURL_OPTIONS \
    -H "Authorization: bearer $GOCD_API_TOKEN" \
    -H 'Accept: application/vnd.go.cd.v2+json' \
    -H 'X-GoCD-Confirm: true' \
    -X POST
}

function get_latest_stage_run_status() {
  get_stage_run_history $1 $2 | jq -r .stages[0].jobs[0].state
}

function fail_if_stage_running() {
  local pipeline_name=$1
  local stage_name=$2

  local stage_status=$(get_latest_stage_run_status $pipeline_name $stage_name)

  echo Stage $stage_name in $pipeline_name is $stage_status
  if [[ "$stage_status" != "Completed" ]]; then
    echo "Failing e2e tests fast as $pipeline_name is currently running $stage_name"
    exit 37
  fi
  echo Continuing as $pipeline_name $stage_name is not running
}

###########
## TASKS ##
###########

command="$1"
case "${command}" in
  _dep)
      gradle dependencyCheckAnalyze
      ;;
  dep)
      dojo "./tasks _dep"
      ;;
  _test_continuity_e2e)
     gradle test --tests "uk.nhs.prm.deduction.e2e.tests.ContinuityE2E"
      ;;
  test_continuity_e2e)
      check_env
      assume_environment_role $NHS_ENVIRONMENT
      check_suspension_service
      dojo "./tasks _test_continuity_e2e"
      ;;
  _test_repo_e2e)
      gradle test --tests "uk.nhs.prm.deduction.e2e.tests.RepositoryE2ETests"
      ;;
  test_repo_e2e)
      check_env
      assume_environment_role $NHS_ENVIRONMENT
      dojo "./tasks _test_repo_e2e"
      ;;
  _livetest_inject)
      gradle test --tests InjectChangeOfGPMessageTest
      ;;
  livetest_inject)
      check_env
      assume_environment_role $NHS_ENVIRONMENT
      dojo "./tasks _livetest_inject"
      ;;
  _livetest_day1_test)
      gradle test --tests ChangeOfGPMessageReceivedTest
      ;;
  livetest_day1_test)
      check_env
      assume_environment_role $NHS_ENVIRONMENT
      dojo "./tasks _livetest_day1_test"
      ;;
  _livetest_day2_test)
      gradle test --tests ValidateMOFUpdatedTest
      ;;
  livetest_day2_test)
      check_env
      assume_environment_role $NHS_ENVIRONMENT
      dojo "./tasks _livetest_day2_test"
      ;;
  _livetest_repo_test)
      gradle test --tests ValidateEhrTransferToRepoUsingMofTest
      ;;
  livetest_repo_test)
      check_env
      assume_environment_role $NHS_ENVIRONMENT
      dojo "./tasks _livetest_repo_test"
      ;;
  _test_perf_unit)
      gradle test --tests *.performance.*.*Test
      ;;
  test_perf_unit)
      dojo "./tasks _test_perf_unit"
      ;;
  _test_performance)
      gradle test --tests *.PerformanceTest
      ;;
  test_performance_local) # using local user auth
      check_env
      assume_environment_role $NHS_ENVIRONMENT
      dojo "./tasks _test_performance"
      ;;
  test_performance) # in pipeline
      check_env

      assume_environment_role $NHS_ENVIRONMENT
      set_required_role_arn_from_assumed_role
      echo "set REQUIRED_ROLE_ARN to $REQUIRED_ROLE_ARN for long-running test process"

      echo "NB: clearing temporary auth session credentials to allow native AWS auth access to re-assume role after expiry"
      _clear_aws_env_credentials

      dojo "./tasks _test_performance"
      ;;
  _test_repo_in_performance)
      gradle test --tests *.RepoInPerformanceTest
      ;;
  test_repo_in_performance)
      check_env

      assume_environment_role $NHS_ENVIRONMENT
      set_required_role_arn_from_assumed_role
      echo "set REQUIRED_ROLE_ARN to $REQUIRED_ROLE_ARN for long-running test process"

      echo "NB: clearing temporary auth session credentials to allow native AWS auth access to re-assume role after expiry"
      _clear_aws_env_credentials

      dojo "./tasks _test_repo_in_performance"
      ;;
  _test_technical)
      gradle test --tests *ChangeOfGPMessageReceivedTest
      ;;
  test_technical)
      ;;
  _ehr_tool)
      export MESSAGES_DIR=tools/large-ehr-inspector/samples
      export TEMPLATE_MESSAGE_ID=9e6f8d45-913a-4c67-89f3-10d131fc332c
      export TARGET_MESSAGE_ID=be6f8d45-913a-4c67-89f3-10d131fc332c
      gradle ehrTool
      ;;
  _check_gocd_job)
      # simplified pipelines next steps:

      # note:
      # create versions manifest - then can just check is identical at end of tests?
      # ... well not quite if you want to optimise - as e.g. if one gets scheduled or assigned
      # but is not building yet, it needn't invalidate run, but for simplicity:

      # make sure all are in state completed at start of run

      # NB there is a Cancel stage API which would be better if can be used on self than this red fail
      fail_if_stage_running pds-adaptor deploy.dev
      fail_if_stage_running nems-event-processor deploy.dev

      echo No deployments running into dev. Starting e2e tests

      # make sure all are in state completed at end of run, including which pipeline stage and job run number

      # if start and end manifests not identical, fail build due to potential changes while tests running (tests
      # should then automatically re-run when in-flight or completed change triggers this test job again)

      # next is to find latest previous passing run of this e2e tests job

      # then next is to compare this manifests versions to previous passing manifest, and trigger next stages in those
      # pipelines that have different version IDs... or maybe actually safer to check latest completed next stage on
      # each microservice pipeline and trigger next stage if doesn't match? probably the prior - stick to e2e tests
      # triggering with reference to itself and prebvious runs - if other failures or re-runs occur that is a case for
      # manual repair

      # think about / try inline e2e-tests in microservices pipelines? probs need to check only one e2e tests running at
      # a time as well as no other deploys going on

      ;;
  check_gocd_job)
      dojo -c Dojofile-infra "./tasks _check_gocd_job"
      ;;
  _trigger_gocd_job)
      # NB there is a https://api.gocd.org/21.3.0/#comment-on-pipeline-instance API which maybe could add
      # some tracking info to this trigger, although it looks like comment is across whole pipeline run
      # and not stage specific meaning it could be a bit verbose / inappropriate to add comments for all triggers

      # was also thinking: one drawback to not having the e2e test process in the pipeline is we don't get to see the
      # red build within the pipeline - however we could have a job inline in the microservice pipeline that waits for
      # the automatically-triggered e2e tests job to complete and then continues (or fails or cancels) based


      echo automatic material dependency locator for pds-adaptor material is $GO_DEPENDENCY_LOCATOR_PDS_ADAPTOR
      trigger_stage_run $(echo $GO_DEPENDENCY_LOCATOR_PDS_ADAPTOR | sed 's/deploy.dev\/.*/prepare.test/')
      echo automatic material dependency locator for nems-event-processor material is $GO_DEPENDENCY_LOCATOR_NEMS_EVENT_PROCESSOR
      trigger_stage_run $(echo $GO_DEPENDENCY_LOCATOR_NEMS_EVENT_PROCESSOR | sed 's/deploy.dev\/.*/prepare.test/')
      ;;
  trigger_gocd_job)
      dojo -c Dojofile-infra "./tasks _trigger_gocd_job"
      ;;
  *)
      echo "Invalid command: '${command}'"
      exit 1
      ;;

esac
set +e
